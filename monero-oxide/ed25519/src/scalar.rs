use core::ops::DerefMut;

#[allow(unused_imports)]
use std_shims::prelude::*;
use std_shims::io::{self, *};

use subtle::{Choice, ConstantTimeEq};
use zeroize::{Zeroize, Zeroizing};

use rand_core::{RngCore, CryptoRng};

use sha3::{Digest, Keccak256};

use monero_io::*;

/// 縮約された（reduced）スカラー。
///
/// 英語原文: A reduced scalar.
#[derive(Clone, Copy, Eq, Debug, Zeroize)]
pub struct Scalar([u8; 32]);

impl ConstantTimeEq for Scalar {
  fn ct_eq(&self, other: &Self) -> Choice {
    self.0.ct_eq(&other.0)
  }
}
impl PartialEq for Scalar {
  /// This defers to `ConstantTimeEq::ct_eq`.
  fn eq(&self, other: &Self) -> bool {
    bool::from(self.ct_eq(other))
  }
}

impl Scalar {
  /// 加法単位元（0）。
  pub const ZERO: Self = Self([0; 32]);
  /// 乗法単位元（1）。
  #[rustfmt::skip]
  pub const ONE: Self = Self([
    1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  ]);
  /// `8 mod l` の逆数（乗法逆元）。
  ///
  /// 補足: `l` は Ed25519 曲線上の点の個数に含まれる大きな素因子です。
  /// 小位数部分（small-order subgroup）を除去する操作で利用されます。
  #[rustfmt::skip]
  pub const INV_EIGHT: Self = Self([
    121,  47, 220, 226,  41, 229,   6,  97, 208, 218,  28, 125, 179, 157, 211,   7,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   6,
    ]);

  /// `Scalar` をバイト列として書き出します。
  ///
  /// 補足: この操作は可変時間で実行される可能性があります。
  pub fn write<W: Write>(&self, w: &mut W) -> io::Result<()> {
    w.write_all(&self.0)
  }

  /// 正準的にエンコードされたスカラーを読み込みます。
  ///
  /// 補足: Monero プロトコルでは一部スカラーが正準表現でない場合があるため、
  /// その場合は `[u8; 32]` として扱い、必要時にスカラーに変換すべきです。
  ///
  /// 注意: この操作は可変時間です。
  pub fn read<R: Read>(r: &mut R) -> io::Result<Scalar> {
    let bytes = read_bytes(r)?;
    Option::<curve25519_dalek::Scalar>::from(curve25519_dalek::Scalar::from_canonical_bytes(bytes))
      .ok_or_else(|| io::Error::other("unreduced scalar"))?;
    Ok(Self(bytes))
  }

  /// `curve25519_dalek::Scalar` から `Scalar` を生成します（内部用）。
  ///
  /// 補足: API 公約外のため公開していません。
  #[doc(hidden)]
  pub fn from(scalar: curve25519_dalek::Scalar) -> Self {
    Self(scalar.to_bytes())
  }

  /// Create a `curve25519_dalek::Scalar` from a `Scalar`.
  ///
  /// This is hidden as it is not part of our API commitment. No guarantees are made for it.
  #[doc(hidden)]
  pub fn into(self) -> curve25519_dalek::Scalar {
    curve25519_dalek::Scalar::from_canonical_bytes(self.0)
      .expect("`Scalar` instantiated with invalid contents")
  }

  /// RNG から一様なスカラーをサンプリングします（内部用）。
  ///
  /// 補足: API 公約外のため公開していません。
  #[doc(hidden)]
  pub fn random(rng: &mut (impl RngCore + CryptoRng)) -> Self {
    let mut raw = Zeroizing::new([0; 64]);
    rng.fill_bytes(raw.deref_mut());
    Self(Zeroizing::new(curve25519_dalek::Scalar::from_bytes_mod_order_wide(&raw)).to_bytes())
  }

  /// ハッシュ関数からスカラーを導出します（`keccak256(data) % l`）。
  ///
  /// 補足: これはワイドリダクションではありません。極めて稀なケースで `l` の倍数に一致する
  /// 事象が見つかった場合はパニックします（実装上の判断）。
  pub fn hash(data: impl AsRef<[u8]>) -> Self {
    let scalar =
      curve25519_dalek::Scalar::from_bytes_mod_order(Keccak256::digest(data.as_ref()).into());

    /*
      Monero errors in this case to ensure its integrity, yet its of negligible probability to the
      degree Monero's integrity will be compromised by _other_ methods much much sooner.

      Accordingly, we don't propagate the error, and simply panic here. The end result is
      effectively the same: We will not claim proofs which generate zero challenges are valid. We
      just will panic, instead of flagging them as invalid.
    */
    assert!(
      scalar != curve25519_dalek::Scalar::ZERO,
      "keccak256(preimage) \\cong 0 \\mod l! Preimage: {:?}",
      data.as_ref()
    );

    Self::from(scalar)
  }
}

impl From<Scalar> for [u8; 32] {
  fn from(scalar: Scalar) -> [u8; 32] {
    scalar.0
  }
}
